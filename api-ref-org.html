<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>The Playhead audio server</title>
    <style>
        * {
            touch-action: none;
        }

        body {
            background-color: #333;
            color: #ccc;
            font-family: sans-serif;
            /* touch-action: none; */
        }

        #logo {
            position: absolute;
            right: 20px;
            top: 20px;
        }

        h2 {
            font-family: sans-serif;
            color: #c80;
            margin: 0px;
            font-size: 1rem;
            margin-top: 0.8rem;
        }

        a {
            font-family: sans-serif;
            background-color: #ddc;
            border: 1px solid #222;
            box-shadow: 2px 2px 2px #000;
            padding: 8px 8px;
            margin: 3px;
            color: #000;
            font-weight: bold;
            display: inline-block;
            text-decoration: none;
        }

        .dial {
            margin: 4px;
            border: 1px solid #ccc;
            background-image: url('dark/cap_bg.png');
        }

        #keyboard {
            display: flex;
            user-select: none;
        }

        .octave {
            width: 25rem;
            position: relative;
        }

        .whites {
            display: flex;
        }

        .whites div {
            width: 14.3%;
            border: 1px solid #000;
            border-radius: 0px 0px 3px 3px;
            cursor: pointer;
            height: 10rem;
            background: white;
            transition: background-color 0.2s ease-in-out;
        }

        .whites div.pressed {
            background-color: #ff9900;
            transition: background-color 0.0s ease-in-out;
        }

        .whites span {
            position: absolute;
            padding: 3px;
            font-size: 0.8rem;
            color: #666;
            bottom: 0px;
        }

        .blacks {
            position: absolute;
            top: 0px;
            width: 100%;
        }

        .blacks div {
            position: absolute;
            width: 8%;
            border: 1px solid #000;
            border-radius: 0px 0px 4px 4px;
            background-color: #000;
            height: 6rem;
        }

        .blacks div.pressed {
            background-color: #994400;
        }


        .blacks div:nth-child(1) {
            left: 8.75%;
        }

        .blacks div:nth-child(2) {
            left: 25.25%;
        }

        .blacks div:nth-child(3) {
            left: 51%;
        }

        .blacks div:nth-child(4) {
            left: 67%;
        }

        .blacks div:nth-child(5) {
            left: 83%;
        }
    </style>
</head>

<body>
    <div id="logo"><img src="tph.png"></div>
    <table>
        <tr>
            <td>
                <h2>Server</h2>
                <a href="/rpc?method=server.quit" target="if">Shut down server</a>

                <h2>Device</h2>
                need some example here..

                <h2>Project</h2>
                <a href="/rpc?method=project.load&value=demo" target="if">Load demo project</a>
                <a href="/rpc?method=project.save&value=demo" target="if">Save demo project</a>
                <a href="/rpc?method=project.set&key=bpm&value=88" target="if">88 bpm</a>
                <a href="/rpc?method=project.set&key=bpm&value=120" target="if">120 bpm</a>
                <a href="/rpc?method=project.set&key=master_tune&value=432" target="if">432 Hz</a>

                <h2>Rack (synths)</h2>
                <a href="/rpc?method=rack.mount&key=synth&value=Subreal&rack_id=0" target="if">Mount Subreal to zero</a>
                <h2>Rack (effects)</h2>
                <a href="/rpc?method=rack.mount&key=effect1&value=Delay&rack_id=0" target="if">Mount Delay to
                    effect1</a>
                <a href="/rpc?method=rack.mount&key=effect2&value=Chorus&rack_id=0" target="if">Mount Chorus to
                    effect2</a>
                <a href="/rpc?method=rack.mount&key=effect1&value=&rack_id=0" target="if">un-mount effect1</a>
                <h2>Rack (eventors)</h2>
                <a href="/rpc?method=rack.mount&key=eventor1&value=Third&rack_id=0" target="if">Mount Third to
                    eventor1</a>
                <a href="/rpc?method=rack.mount&key=eventor2&value=Fifth&rack_id=0" target="if">Mount Fifth to
                    eventor2</a>
                <a href="/rpc?method=rack.mount&key=eventor1&value=Arpeggiator&rack_id=0" target="if">Mount Arpeggio to
                    eventor1</a>
                <a href="/rpc?method=rack.mount&key=eventor1&value=&rack_id=0" target="if">un-mount eventor1</a>

                <h2>Unit</h2>
                <a href="/rpc?method=unit.set&unit=synth&key=lut1_overtones&value=0.4,0.3,0.2&rack_id=0"
                    target="if">Setup LUT0</a>
                <a href="/rpc?method=unit.set&unit=synth&key=lut2_overtones&value=0.4,0,0,0,0,0.5&rack_id=0"
                    target="if">Setup
                    LUT1</a>
                <a href="/rpc?method=unit.patchLoad&unit=synth&value=Submarino&rack_id=0" target="if">Load patch
                    Submarino</a>
                <a href="http://localhost:18080/rpc?method=unit.patchSave&unit=synth&value=Submarino2&rack_id=0"
                    target="if">Save
                    patch Submarino2</a>
                <h2>Unit</h2>
                <a href="/rpc?method=unit.param&rack_id=0&unit=synth&key=osc_mix&value=111" target="if">set osc_mix -
                    rack 0</a>
                <a href="/rpc?method=unit.param&rack_id=0&unit=effect1&key=0&value=111" target="if">set effect1 param0
                    (not midi
                    aware), rack 0</a>
            </td>
            <td>
                <h2>(old stuff below.. not working)</h2>
                duh..
                <table width="90%">
                    <tr>
                        <td width="50%">
                            <h2>JSON RPC response</h2>
                            <iframe name="if" width="500" height="200"></iframe>
                        </td>
                        <td>
                            <h2>WEB Socket output</h2>
                            <div id="socketOutput"
                                style="width:500px;height:200px;border:1px solid #000;overflow-y: scroll;"></div>
                        </td>
                    </tr>
                </table>

            </td>
        </tr>
    </table>

    <h2>Web Socket Testing</h2>
    <div id="slider-container">
        <label for="cc-slider">MIDI CC #16</label>
        <input type="range" id="cc-slider" data-cc_number="16" min="0" max="127" value="64">
    </div>

    <div id="app">
        <div @mousedown="swypeBegin($event)" @touchstart.prevent="swypeBegin($event)">
            <div class="flexcontainer" style="display:flex">
                <div class="dial" style="left:29px;top:29px;" width="64" id="cc_10">
                    <img class="knob" data-type="knob" draggable="false" src="/fe/dark/cap.png"
                        :style="calcKnobRotation('cc_10')" id="cc_10" />
                </div>
            </div>
        </div>
    </div>


    <h2>Key roll</h2>
    <div id="keyboard">
        <div class="octave">
            <div class="whites">
                <div id="key_30"><span>C3</span></div>
                <div id="key_32"></div>
                <div id="key_34"></div>
                <div id="key_35"></div>
                <div id="key_37"></div>
                <div id="key_39"></div>
                <div id="key_3B"></div>
            </div>
            <div class="blacks">
                <div id="key_31"></div>
                <div id="key_33"></div>
                <div id="key_36"></div>
                <div id="key_38"></div>
                <div id="key_3A"></div>
            </div>
        </div>
        <div class="octave">
            <div class="whites">
                <div id="key_3C"><span>C4</span></div>
                <div id="key_3E"></div>
                <div id="key_40"></div>
                <div id="key_41"></div>
                <div id="key_43"></div>
                <div id="key_45"></div>
                <div id="key_47"></div>
            </div>
            <div class="blacks">
                <div id="key_3D"></div>
                <div id="key_3F"></div>
                <div id="key_42"></div>
                <div id="key_44"></div>
                <div id="key_46"></div>
            </div>
        </div>

        <div class="octave">
            <div class="whites">
                <div id="key_48"><span>C5</span></div>
                <div id="key_4A"></div>
                <div id="key_4C"></div>
                <div id="key_4D"></div>
                <div id="key_4F"></div>
                <div id="key_51"></div>
                <div id="key_53"></div>
            </div>
            <div class="blacks">
                <div id="key_49"></div>
                <div id="key_4B"></div>
                <div id="key_4E"></div>
                <div id="key_50"></div>
                <div id="key_52"></div>
            </div>
        </div>
    </div>

    <script src="vue.js"></script>

    <script>
        let ws; // Global variable, but initialized later.  needed for sendMidi => vue

        function hex2dec(hex) {
            return parseInt(hex, 16);
        }

        document.addEventListener("DOMContentLoaded", function () {
            //0 insert vue.js here now..
            const app = Vue.createApp({
                data() {
                    return {
                        eventTarget: '',
                        startX: 0,
                        startY: 0,
                        startTime: 0,
                        rotating: false,
                        title: 'the title',
                        titleClass: "theBold",
                        cc_10: 80,
                        cc_12: 80,
                        vueLog: "duh",
                        vueLog2: "dah",
                    }
                },
                computed: {
                },
                methods: {
                    calcKnobRotation(prop) {
                        const rotationAngle = this[prop] * 2 - 128;
                        return {
                            rotate: rotationAngle + 'deg'
                        }
                    },
                    getTitleClass() {
                        return this.titleClass;
                    },
                    updateCC(ccNumber, ccValue) {
                        this[ccNumber] = ccValue; // Updates the reactive Vue data
                    },

                    swypeBegin(event) {
                        // Check if the event target is an image
                        if (event.target.dataset.type === 'knob') {
                            console.log('here');
                            event.preventDefault();
                            this.startTime = performance.now();
                            //this.startX = event.clientX || event.touches[0].clientX;
                            //this.startY = event.clientY || event.touches[0].clientY;
                            this.startX = event.touches ? event.touches[0].clientX : event.clientX;
                            this.startY = event.touches ? event.touches[0].clientY : event.clientY;
                            this.eventTarget = event.target.id;
                            this.swypeAxis = '';
                            this.orgCC = this[this.eventTarget];
                            this.rotating = true;

                            // Log the data-type attribute value
                            const dataType = event.target.dataset.type;
                            this.vueLog = `data-type attribute value: ${dataType}`;

                            document.addEventListener('mousemove', this.swypeDo);
                            document.addEventListener('mouseup', this.swypeEnd);
                            document.addEventListener('touchmove', this.swypeDo);
                            document.addEventListener('touchend', this.swypeEnd);
                        }
                    },

                    swypeDo(event) {
                        if (this.rotating) {
                            //const diffX = (event.clientX || event.touches[0].clientX) - this.startX;
                            const diffX = (event.touches ? event.touches[0].clientX : event.clientX) - this.startX;
                            //const diffY = this.startY - (event.clientY || event.touches[0].clientY);
                            const diffY = this.startY - (event.touches ? event.touches[0].clientY : event.clientY);
                            this.vueLog = `Mouse diff at (${diffX}, ${diffY})`;
                            //based on current data value and offset, calc new cc-value
                            //we can't use this, provides funny results on long press: const currCC = this[this.eventTarget];
                            let newCC = this.orgCC;
                            switch (this.swypeAxis) {
                                case '':
                                    //find out which axis to go.
                                    if (Math.abs(diffY) > 3 && Math.abs(diffX) < 3) {
                                        this.swypeAxis = 'Y';
                                    }
                                    if (Math.abs(diffX) > 3 && Math.abs(diffY) < 3) {
                                        this.swypeAxis = 'X';
                                    }
                                //continue
                                case 'Y':
                                    newCC = Math.round(this.orgCC + diffY / 2);
                                    break;
                                case 'X':
                                    newCC = Math.round(this.orgCC + diffX / 10);
                                    break;
                            }
                            if (newCC < 0) newCC = 0;
                            if (newCC > 127) newCC = 127;
                            //console.log('target:' + this.eventTarget);
                            this.sendCC(this.eventTarget, newCC);
                            endTime = performance.now();
                            //console.log(`Swipe duration: ${endTime - this.startTime} ms`);
                        }
                    },
                    sendCC(ccName, ccVal) {
                        //really send this to web-socket server and let that server set the data anytime,
                        //but fake now.
                        //wsRequest('yada-yada'..)
                        //well really only send if there's a new value..
                        if (ccVal != this[ccName]) {
                            console.log(ccName + ', ' + ccVal);
                            let ccNumber = ccName.replace("cc_", "");
                            let ccValue = Number(ccVal).toString(16).padStart(2, "0"); // Convert value to hex
                            let midi = '0xB0' + ccNumber + ccValue;
                            console.log(midi);
                            sendMidi(midi);
                            //Working: this.cc_10 = ccVal;
                        }
                    },

                    swypeEnd(event) {
                        this.rotating = false;
                        document.removeEventListener('mousemove', this.swypeDo);
                        document.removeEventListener('mouseup', this.swypeEnd);
                        document.removeEventListener('touchmove', this.swypeDo);
                        document.removeEventListener('touchend', this.swypeEnd);
                    },
                }
            });
            const mountedApp = app.mount('#app');



            //1 Establish web-socket connection
            // Get the hostname and port from the current page
            const hostname = window.location.hostname;
            const port = window.location.port ? window.location.port : (window.location.protocol === 'https:' ? '443' : '80');

            // Construct the WebSocket URL (ws or wss depending on whether the site is served over HTTP or HTTPS)
            const wsProtocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const wsUrl = `${wsProtocol}${hostname}:${port}/ws`;
            // WebSocket initialization
            //const ws = new WebSocket(wsUrl);
            ws = new WebSocket(wsUrl);

            // WebSocket event handlers
            ws.onopen = function () {
                console.log("WebSocket connection established.");
            };

            ws.onclose = function () {
                console.log("WebSocket connection closed.");
            };

            ws.onerror = function (error) {
                console.log("WebSocket error: ", error);
            };

            //2 On recieve message - what to do?
            ws.onmessage = function (event) {
                const message = event.data.trim(); // Ensure no extra spaces

                const socketOutput = document.getElementById("socketOutput");
                const newMessage = document.createElement("div");
                newMessage.textContent = message;
                // Append new message to the div
                socketOutput.appendChild(newMessage);

                if (message.startsWith("0x90") || message.startsWith("0x80")) {
                    const noteHex = message.substring(4, 6); // Extract note value (e.g., "3C")
                    const isNoteOn = message.startsWith("0x90"); // Check if it's Note On or Off
                    const keyElement = document.getElementById(`key_${noteHex.toUpperCase()}`); // Convert to uppercase for consistency

                    if (keyElement) {
                        if (isNoteOn) {
                            console.log("pressing..");
                            keyElement.classList.add("pressed");
                        } else {
                            keyElement.classList.remove("pressed");
                        }
                    }
                }
                if (message.startsWith("0xB0")) {
                    //oops. now it's the other way around. i need to access the vue-instance..
                    const ccNumber = message.substring(4, 6);
                    const ccValue = hex2dec(message.substring(6, 8));
                    //mountedApp.cc_10 = ccValue;
                    const ccProperty = `cc_${ccNumber}`;
                    mountedApp[ccProperty] = ccValue;
                    //console.log('duh - cc message recieved.' + ccValue);
                }
            };

            // Disable double-tap zoom on mobile devices and prevent click delay
            document.addEventListener('touchstart', function (event) {
                event.preventDefault();  // Prevent default touch action (like double-tap zoom)
            }, { passive: false });

            // MIDI CC Slider Handling
            const slider = document.getElementById("cc-slider");

            slider.addEventListener("input", function () {
                const ccNumber = slider.dataset.cc_number; // Read CC number from data attribute
                const value = slider.value;
                if (ws.readyState === WebSocket.OPEN) {
                    const hexMessage = `0xB0${Number(ccNumber).toString(16).padStart(2, '0')}${Number(value).toString(16).padStart(2, '0')}`;
                    sendMidi(hexMessage);
                    //ws.send(JSON.stringify({ midi: hexMessage }));
                    //working - sending 0xB0104b etc..
                    //console.log("Sent MIDI:", hexMessage);
                }
            });

            const keyContainer = document.getElementById("keyboard");
            slideTrigger = false;
            triggeredNote = "00";      //note multi-touch compatible but for now..

            // Handle touch or mouse events to press keys
            function handleKeyPress(event) {
                event.preventDefault();  // Prevent default behavior (scrolling, etc.)
                const key = event.target.closest("[id^='key_']");
                if (key) {
                    const midiKey = key.id.substring(4);
                    sendMidi("0x90" + midiKey + "50");
                    slideTrigger = true;
                    triggeredNote = midiKey;
                }
            }

            // Handle touch or mouse events to release keys
            function handleKeyRelease(event) {
                const key = event.target.closest("[id^='key_']");
                if (key) {
                    const midiKey = key.id.substring(4);
                    sendMidi("0x80" + midiKey + "80");
                    slideTrigger = false;
                    triggeredNote = "00";
                }
            }

            function handleSlidePress(event) {
                if (slideTrigger) {
                    const key = event.target.closest("[id^='key_']");
                    const midiKey = key.id.substring(4);
                    if (midiKey != triggeredNote) {
                        sendMidi("0x80" + triggeredNote + "00");
                        triggeredNote = "00";
                        handleKeyPress(event);
                    }
                }
            }

            // Attach event listeners for continuous touch/mouse events
            keyContainer.addEventListener("touchstart", handleKeyPress);
            keyContainer.addEventListener("mousedown", handleKeyPress);

            keyContainer.addEventListener("touchend", handleKeyRelease);
            keyContainer.addEventListener("mouseup", handleKeyRelease);

            // Add touchmove and mousemove for continuous key press while sliding
            keyContainer.addEventListener("touchmove", handleSlidePress);
            keyContainer.addEventListener("mousemove", handleSlidePress);


            // Function to send MIDI over WebSocket
            function sendMidi(hexMessage) {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(hexMessage);
                }
            }

        });
    </script>

</body>

</html>